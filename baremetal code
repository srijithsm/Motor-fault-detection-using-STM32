/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include <stm32f405xx.h>

uint16_t adc_val = 0;
uint16_t voltage = 0;

void GPIO_Init(void);
void ADC1_Init(void);
uint16_t ADC_Read(void);
void delay(volatile uint32_t count);

int main(void)
{
    GPIO_Init();
    ADC1_Init();

    while (1)
    {
        adc_val = ADC_Read();
        voltage = (adc_val * 3.3) / 4095;


        if (adc_val > 4000)  // Overvoltage (approx > 3.2V)
        {
        	 GPIOD->ODR |= (1 << 13);   // Set PD13

        }
        else if (adc_val < 4000 && adc_val > 1000) {
        	GPIOD->ODR &= ~(1 << 13);
        }

        else if (adc_val < 1000)  // Undervoltage (approx < 2.7V)
        {
            // Motor ON
        	 GPIOD->ODR |= (1 << 13);  // Reset PD13
        }

        delay(1000000);
    }
}

void GPIO_Init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;  // Enable clock to GPIOD
    GPIOD->MODER |= (1 << 26);           // PD13 as output
    GPIOD->OTYPER &= ~(1 << 13);         // Push-pull
    GPIOD->OSPEEDR |= (1 << 26);         // High speed
    GPIOD->PUPDR &= ~(3 << 26);          // No pull-up/down
}

void ADC1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;      // Enable ADC1 clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;     // Enable GPIOA clock

    GPIOA->MODER |= (3 << (1 * 2));          // PA1 as analog mode

    ADC1->CR2 = 0;                           // Disable ADC to configure
    ADC1->SQR3 = 1;                          // Channel 1 (PA1)
    ADC1->SMPR2 |= (7 << 3);                 // Sample time 480 cycles
    ADC1->CR2 |= ADC_CR2_ADON;              // Enable ADC1
}

uint16_t ADC_Read(void)
{
    ADC1->CR2 |= ADC_CR2_SWSTART;           // Start conversion
    while (!(ADC1->SR & ADC_SR_EOC));       // Wait until conversion complete
    return ADC1->DR;
}

void delay(volatile uint32_t count)
{
    while (count--) __NOP();
}
