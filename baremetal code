/**
 ******************************************************************************
 * @file           : main.c
 * @author         :
 * @brief          : Main program body with LCD Display
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f405xx.h>

// ------------------ LCD PIN DEFINITIONS ------------------
#define LCD_RS 0
#define LCD_EN 1
#define LCD_D4 2
#define LCD_D5 3
#define LCD_D6 4
#define LCD_D7 5

// ------------------ FUNCTION DECLARATIONS ------------------
void GPIO_Init(void);
void ADC1_Init(void);
uint16_t ADC_Read(void);
void delay(volatile uint32_t count);

// LCD Functions
void LCD_Init(void);
void LCD_Command(uint8_t cmd);
void LCD_Char(char data);
void LCD_String(char *str);
void LCD_Send4Bits(uint8_t data);
void LCD_Pulse(void);
void LCD_Clear(void);

// ------------------ GLOBAL VARIABLES ------------------
uint16_t adc_val = 0;
uint16_t voltage = 0;

// ========================================================
//                      MAIN FUNCTION
// ========================================================
int main(void)
{
    GPIO_Init();
    ADC1_Init();
    LCD_Init();

    LCD_Clear();
    LCD_String("Motor System");
    delay(2000000);
    LCD_Clear();

    while (1)
    {
        adc_val = ADC_Read();
        voltage = (adc_val * 3.3) / 4095;

        if (adc_val > 4000) // Over current
        {
            GPIOD->ODR |= (1 << 13);
            LCD_Clear();
            LCD_String("OVER CURRENT!");
        }
        else if (adc_val < 4000 && adc_val > 1000) // Normal
        {
            GPIOD->ODR &= ~(1 << 13);
            LCD_Clear();
            LCD_String("GOOD FLOW");
        }
        else if (adc_val < 1000) // Very low (motor on)
        {
            GPIOD->ODR |= (1 << 13);
            LCD_Clear();
            LCD_String("LOW CURRENT");
        }

        delay(1000000);
    }
}

// ========================================================
//                   GPIO INITIALIZATION
// ========================================================
void GPIO_Init(void)
{
    // PD13 Output
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
    GPIOD->MODER |= (1 << 26);
    GPIOD->OTYPER &= ~(1 << 13);
    GPIOD->OSPEEDR |= (1 << 26);
    GPIOD->PUPDR &= ~(3 << 26);

    // LCD GPIOB Pins
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

    // PB0â€“PB5 as output
    GPIOB->MODER |= (1 << (LCD_RS * 2)) |
                    (1 << (LCD_EN * 2)) |
                    (1 << (LCD_D4 * 2)) |
                    (1 << (LCD_D5 * 2)) |
                    (1 << (LCD_D6 * 2)) |
                    (1 << (LCD_D7 * 2));
}

// ========================================================
//                      ADC INITIALIZATION
// ========================================================
void ADC1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

    GPIOA->MODER |= (3 << (1 * 2)); // PA1 analog

    ADC1->CR2 = 0;
    ADC1->SQR3 = 1;
    ADC1->SMPR2 |= (7 << 3);
    ADC1->CR2 |= ADC_CR2_ADON;
}

uint16_t ADC_Read(void)
{
    ADC1->CR2 |= ADC_CR2_SWSTART;
    while (!(ADC1->SR & ADC_SR_EOC));
    return ADC1->DR;
}

// ========================================================
//                      BASIC DELAY
// ========================================================
void delay(volatile uint32_t count)
{
    while (count--) __NOP();
}

// ========================================================
//                      LCD FUNCTIONS
// ========================================================
void LCD_Pulse(void)
{
    GPIOB->ODR |= (1 << LCD_EN);
    delay(2000);
    GPIOB->ODR &= ~(1 << LCD_EN);
    delay(2000);
}

void LCD_Send4Bits(uint8_t data)
{
    GPIOB->ODR &= ~((1 << LCD_D4) | (1 << LCD_D5) | (1 << LCD_D6) | (1 << LCD_D7));

    if (data & 0x01) GPIOB->ODR |= (1 << LCD_D4);
    if (data & 0x02) GPIOB->ODR |= (1 << LCD_D5);
    if (data & 0x04) GPIOB->ODR |= (1 << LCD_D6);
    if (data & 0x08) GPIOB->ODR |= (1 << LCD_D7);

    LCD_Pulse();
}

void LCD_Command(uint8_t cmd)
{
    GPIOB->ODR &= ~(1 << LCD_RS); // RS = 0
    LCD_Send4Bits(cmd >> 4);
    LCD_Send4Bits(cmd & 0x0F);
}

void LCD_Char(char data)
{
    GPIOB->ODR |= (1 << LCD_RS); // RS = 1
    LCD_Send4Bits(data >> 4);
    LCD_Send4Bits(data & 0x0F);
}

void LCD_String(char *str)
{
    while (*str)
    {
        LCD_Char(*str++);
    }
}

void LCD_Clear(void)
{
    LCD_Command(0x01);
    delay(3000);
}

void LCD_Init(void)
{
    delay(50000);

    LCD_Send4Bits(0x03);
    delay(10000);
    LCD_Send4Bits(0x03);
    delay(10000);
    LCD_Send4Bits(0x03);
    delay(10000);

    LCD_Send4Bits(0x02); // 4-bit mode

    LCD_Command(0x28);   // 2 lines, 4-bit
    LCD_Command(0x0C);   // Display ON
    LCD_Command(0x06);   // Auto increment
    LCD_Command(0x01);   // Clear display
}
